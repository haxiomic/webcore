<!DOCTYPE html>

<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
		<meta charset="utf-8">
		<style>
			body {
				margin: 0;
				overflow: hidden;
				position: fixed;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<script src="app.js"></script>
		<script>
			let pixelRatio = window.devicePixelRatio != null ? window.devicePixelRatio : 1;

			// initialize our haxe app
			let appInstance = HaxeApp.create();

			// create a canvas to provide the OpenGL context
			let canvas = document.createElement('canvas');
			document.body.appendChild(canvas);

			canvas.style.display = 'block';

			// disable default touch actions, this helps disable view dragging on touch devices
			canvas.style.touchAction = 'none';
			canvas.setAttribute('touch-action', 'none');
			// prevent native touch-scroll
			let cancelEvent = (e) => {
				e.preventDefault();
				e.stopPropagation();
			}
			canvas.addEventListener('gesturestart', cancelEvent, false);
			canvas.addEventListener('gesturechange', cancelEvent, false);
			// canvas.addEventListener('scroll', cancelEvent);

			// add canvas gl context listeners to encourage powerPreference to be respected
			canvas.addEventListener('webglcontextlost', () => {
				appInstance.onNativeGraphicsContextLost();
				cancelAnimationFrame(requestAnimationFrameHandle);
			});
			canvas.addEventListener('webglcontextrestored', () => {
				appInstance.onGraphicsContextReady(gl);
				frameLoop(performance.now());
			});

			// get the webgl context
			let webglContextAttributes = {
				antialias: true,
				stencil: false,
				depth: false,
				alpha: false,
				premultipliedAlpha: false,
				preserveDrawingBuffer: false,
				powerPreference: 'high-performance',
				desynchronized: true,
			}

			let gl = canvas.getContext('webgl', webglContextAttributes);
			let requestAnimationFrameHandle = -1;
			
			appInstance.onGraphicsContextReady(gl);

			// Pointer Input
			
			function executePointerMethodFromMouseEvent(mouseEvent, pointerMethod) {
				// trackpad force
				let force = mouseEvent.force || mouseEvent.webkitForce;

				// convert force to a 0 - 1 range
				let pressure = force !== undefined ? Math.max((force - 1), 0) : 0.5;

				pointerMethod({
					pointerId: -1,
					pointerType: 'mouse',
					isPrimary: true,
					button: mouseEvent.button,
					buttons: mouseEvent.buttons,
					x: mouseEvent.clientX,
					y: mouseEvent.clientY,
					width: 1,
					height: 1,
					pressure: pressure,
					tangentialPressure: 0,
					tiltX: 0,
					tiltY: 0,
					twist: 0,
				});
			}

			// Map<type, {primaryTouchIdentifier: Int, activeCount: Int}>
			let touchInfoForType = {}
			function getTouchInfoForType(type) {
				let touchInfo = touchInfoForType[type];
				if (touchInfo == null) {
					touchInfoForType[type] = touchInfo = {
						primaryTouchIdentifier: null,
						activeCount: 0,
					}
				}
				return touchInfo;
			}
			function executePointerMethodFromTouchEvent(touchEvent, pointerMethod, preventDefault) {
				if (preventDefault === true) {
					touchEvent.preventDefault(); 
				}

				let button = 0;
				let buttons = 0;
				switch (touchEvent.type) {
					case 'touchstart':
						button = 0;
						buttons = 1;
						break;
					case 'touchmove':
					case 'touchforcechange':
						button = -1;
						buttons = 1;
						break;
				}

				for (let i = 0; i < touchEvent.changedTouches.length; i++) {
					let touch = touchEvent.changedTouches[i];

					// touchforcechange can fire _after_ touchup fires
					// we filter it out by checking if the touch is included in the list of active touches
					if (touchEvent.type === 'touchforcechange') {
						let touchIsActive = false;
						for (let t of touchEvent.touches) {
							if (touch === t) {
								touchIsActive = true;
								break;
							}
						}
						if (!touchIsActive) {
							continue;
						}
					}

					let touchInfo = getTouchInfoForType(touch.touchType);

					// set primary touch as the first active touch
					if (touchInfo.activeCount === 0 && i === 0 && touchEvent.type === 'touchstart') {
						touchInfo.primaryTouchIdentifier = touch.identifier;
					}

					// convert altitude-azimuth to tilt xy
					let tanAlt = Math.tan(touch.altitudeAngle);
					let radToDeg = 180.0 / Math.PI;
					let tiltX = Math.atan(Math.cos(touch.azimuthAngle) / tanAlt) * radToDeg;
					let tiltY = Math.atan(Math.sin(touch.azimuthAngle) / tanAlt) * radToDeg;

					pointerMethod({
						pointerId: touch.identifier,
						pointerType: (touch.touchType === 'stylus') ? 'pen' : 'touch',
						isPrimary: touch.identifier === touchInfo.primaryTouchIdentifier,
						button: button,
						buttons: buttons,
						x: touch.clientX,
						y: touch.clientY,
						width: (touch.radiusX || touch.webkitRadiusX) * 2,
						height: (touch.radiusY || touch.webkitRadiusY) * 2,
						pressure: touch.force,
						tangentialPressure: 0,
						tiltX: tiltX || 0,
						tiltY: tiltY || 0,
						twist: touch.rotationAngle,
					});
				}

				switch (touchEvent.type) {
					case 'touchstart':
						activeTouchCount += touchEvent.changedTouches.length;
						break;
					case 'touchend':
					case 'touchcancel':
						activeTouchCount -= touchEvent.changedTouches.length;
						break;
				}
			}

			let onPointerDown = appInstance.onPointerDown.bind(appInstance);
			let onPointerMove = appInstance.onPointerMove.bind(appInstance);
			let onPointerUp = appInstance.onPointerUp.bind(appInstance);
			let onPointerCancel = appInstance.onPointerCancel.bind(appInstance);
			
			// use PointerEvent API if supported
			if (window.PointerEvent) {
				canvas.addEventListener('pointerdown', onPointerDown);
				window.addEventListener('pointermove', onPointerMove);
				window.addEventListener('pointerup', onPointerUp);
				window.addEventListener('pointercancel', onPointerCancel);
			} else {
				canvas.addEventListener('mousedown', (e) => executePointerMethodFromMouseEvent(e, onPointerDown));
				window.addEventListener('mousemove', (e) => executePointerMethodFromMouseEvent(e, onPointerMove));
				window.addEventListener('webkitmouseforcechanged', (e) => executePointerMethodFromMouseEvent(e, onPointerMove));
				window.addEventListener('mouseforcechanged', (e) => executePointerMethodFromMouseEvent(e, onPointerMove));
				window.addEventListener('mouseup', (e) => executePointerMethodFromMouseEvent(e, onPointerUp));
				let useCapture = true;
				canvas.addEventListener('touchstart', (e) => executePointerMethodFromTouchEvent(e, onPointerDown, true), { capture: useCapture, passive: false });
				window.addEventListener('touchmove', (e) => executePointerMethodFromTouchEvent(e, onPointerMove, true), { capture: useCapture, passive: false });
				window.addEventListener('touchforcechange', (e) => executePointerMethodFromTouchEvent(e, onPointerMove, true), { capture: useCapture, passive: true });
				window.addEventListener('touchend', (e) => executePointerMethodFromTouchEvent(e, onPointerUp, true), {capture: useCapture, passive: true});
				window.addEventListener('touchcancel', (e) => executePointerMethodFromTouchEvent(e, onPointerCancel, true), { capture: useCapture, passive: true });
			}

			// resize canvas with window
			function canvasFillWindow() {
				// - html px units do not match the screen's native resolution
				// - the ratio between html px units and the screen's pixels is stored in devicePixelRatio
				// - the canvas width / height attribute set the size of the drawing buffer
				// - to create a canvas that draws at the screen's native resolution we set 
				canvas.width = Math.round(window.innerWidth * pixelRatio);
				canvas.height = Math.round(window.innerHeight * pixelRatio);
				canvas.style.width = "100%";
				canvas.style.height = "100%";

				appInstance.onResize(canvas.clientWidth, canvas.clientHeight);
			}

			canvasFillWindow();
			window.addEventListener('resize', canvasFillWindow);

			// native browser frame-loop
			function frameLoop(t_ms) {
				// tell app to draw a frame 
				appInstance.onDrawFrame(gl.drawingBufferWidth, gl.drawingBufferHeight);
				requestAnimationFrameHandle = requestAnimationFrame(frameLoop);
			}

			// start the frame loop
			frameLoop(performance.now());
		</script>
	</body>
</html>